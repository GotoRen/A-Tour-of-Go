<!DOCTYPE html>
<html>
<head>
<title>memo.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h2 id="%E5%9E%8B">型</h2>
<ul>
<li>基本型（組み込み型）
<ul>
<li><code>bool</code></li>
<li><code>string</code></li>
<li><code>int</code>
<ul>
<li><code>int8</code></li>
<li><code>int16</code></li>
<li><code>int32</code></li>
<li><code>int64</code></li>
</ul>
</li>
<li><code>uint</code>
<ul>
<li><code>uint8</code></li>
<li><code>uint16</code></li>
<li><code>uint32</code></li>
<li><code>uint64</code></li>
<li><code>uintptr</code></li>
</ul>
</li>
<li><code>byte</code> // uint8 の別名</li>
<li><code>rune</code> // int32 の別名（Unicode のコードポイントを表す）</li>
<li><code>float</code>
<ul>
<li><code>float32</code></li>
<li><code>float64</code></li>
</ul>
</li>
<li><code>complex</code>
<ul>
<li><code>complex64</code></li>
<li><code>complex128</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="%E6%96%87%E6%B3%95">文法</h2>
<ul>
<li>フォーマット
<ul>
<li><code>fmt.Printf(&quot;%表示&quot;, 値)</code></li>
</ul>
</li>
<li>表示
<ul>
<li><code>%T</code>：型</li>
<li><code>%v</code>：値</li>
<li><code>%d</code>：int, uint, ...</li>
<li><code>%g</code>：float64, complex128, ...</li>
</ul>
</li>
<li>宣言
<ul>
<li>型の宣言
<ul>
<li><code>var 変数 型 = 値</code></li>
</ul>
</li>
<li>まとめて宣言</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> (
  変数 型 = 値
  変数 型 = 値
  変数 型 = 値
  ...
)
</div></code></pre>
</li>
<li>定数型（const）
<ul>
<li>フォーマット
<ul>
<li><code>const 定数 = 値</code></li>
</ul>
</li>
<li>例：）</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> World = <span class="hljs-string">"world"</span>
fmt.Println(<span class="hljs-string">"Hello"</span>, World)
</div></code></pre>
<ul>
<li>まとめて宣言</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">const</span> (
  定数 = 値
  定数 = 値
  定数 = 値
  ...
)
</div></code></pre>
</li>
<li>ゼロ値</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int</span>     <span class="hljs-comment">// 0</span>
<span class="hljs-keyword">var</span> f <span class="hljs-keyword">float64</span> <span class="hljs-comment">// 0</span>
<span class="hljs-keyword">var</span> b <span class="hljs-keyword">bool</span>    <span class="hljs-comment">// false</span>
<span class="hljs-keyword">var</span> s <span class="hljs-keyword">string</span>  <span class="hljs-comment">// ""</span>
</div></code></pre>
<ul>
<li>自動型取得
<ul>
<li><code>変数 := 値</code></li>
<li>※ <font color=Red><u>定数<code>const</code>は<code>:=</code>を使って宣言できない</u></font></li>
<li>※ <font color=Red><u>関数内部でのみ使用できる</u></font></li>
</ul>
</li>
<li>文字列と変数の接続
<ul>
<li>文の接続はコンマ<code>,</code>で行う</li>
</ul>
</li>
<li>グローバル変数
<ul>
<li>関数の外側で宣言された変数</li>
<li>グローバルスコープ</li>
<li><code>var 変数 型</code></li>
</ul>
</li>
<li>プライベート変数
<ul>
<li>関数の内側で宣言された変数</li>
<li>プライベートスコープ</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
  <span class="hljs-keyword">var</span> 変数 型
}
</div></code></pre>
</li>
</ul>
<h2 id="%E9%96%A2%E6%95%B0">関数</h2>
<ul>
<li>フォーマット</li>
</ul>
<pre class="hljs"><code><div>func 関数名(引数1 型, 引数2 型, ...) 戻り値の型 {
  return 戻り値
}
</div></code></pre>
<ul>
<li>型の省略
<ul>
<li>型が違う</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>, y <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">int</span></span> { 
     <span class="hljs-keyword">return</span> x + y
}
</div></code></pre>
<ul>
<li>型が同じ</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-comment">// 省略可</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add2</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
     <span class="hljs-keyword">return</span> x + y
}
</div></code></pre>
</li>
<li>戻り値無し
<ul>
<li>例：）</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">split</span><span class="hljs-params">(sum <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span></span> {
    x = sum * <span class="hljs-number">4</span> / <span class="hljs-number">9</span> 
    y = sum - x     
    <span class="hljs-keyword">return</span>
}
</div></code></pre>
</li>
</ul>
<h2 id="for%E6%96%87">for文</h2>
<ul>
<li>フォーマット</li>
</ul>
<pre class="hljs"><code><div>sum := <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> i:=下限; i&lt;上限; i++ {
	処理
}
</div></code></pre>
<ul>
<li>反復条件に式を代入
<ul>
<li>フォーマット</li>
</ul>
<pre class="hljs"><code><div>for i:=初期値; 条件; 式{
  処理
}
</div></code></pre>
<ul>
<li>例：）</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">for</span> d := <span class="hljs-number">1.0</span>; d*d &gt; <span class="hljs-number">1e-10</span>; z -= d {
	d = (z*z - x) / (<span class="hljs-number">2</span> * z)
}
</div></code></pre>
</li>
<li><code>range</code></li>
</ul>
<pre class="hljs"><code><div>変数<span class="hljs-number">1</span> := []型{値<span class="hljs-number">1</span>, 値<span class="hljs-number">2</span>, 値<span class="hljs-number">3</span>, 値<span class="hljs-number">4</span>, ...}
<span class="hljs-keyword">for</span> i, 変数<span class="hljs-number">2</span> := <span class="hljs-keyword">range</span> 変数<span class="hljs-number">1</span> {
		処理
}
</div></code></pre>
<ul>
<li><code>range</code>インデックス無し</li>
</ul>
<pre class="hljs"><code><div>変数<span class="hljs-number">1</span> := []型{値<span class="hljs-number">1</span>, 値<span class="hljs-number">2</span>, 値<span class="hljs-number">3</span>, 値<span class="hljs-number">4</span>, ...}
<span class="hljs-keyword">for</span> _, 変数<span class="hljs-number">2</span> := <span class="hljs-keyword">range</span> 変数<span class="hljs-number">1</span> {
		処理
}
</div></code></pre>
<h2 id="while%E6%96%87">while文</h2>
<ul>
<li>フォーマット</li>
</ul>
<pre class="hljs"><code><div>i := 初期値
<span class="hljs-keyword">for</span> ; 条件式; {
	処理
}
</div></code></pre>
<h2 id="if%E6%96%87">if文</h2>
<ul>
<li>フォーマット</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> 条件式 {
  処理
}
</div></code></pre>
<ul>
<li>ショートステートメント
<ul>
<li>例：）</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">if</span> v := math.Pow(x, n); v &lt; lim {
  <span class="hljs-keyword">return</span> v;
}
</div></code></pre>
<ul>
<li>ifの動き
<ul>
<li><code>v := math.Pow(x, n);</code>
<ul>
<li>計算結果を<code>v</code>に代入</li>
</ul>
</li>
<li><code>v &lt; lim</code>
<ul>
<li><code>v</code>が<code>lim</code>よりも小さい時</li>
</ul>
</li>
<li>※ <code>v</code>はif文内でのみ使用できる</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="switch%E6%96%87">switch文</h2>
<ul>
<li>フォーマット</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">switch</span> 変数 := 条件; 変数 {
  <span class="hljs-keyword">case</span> 条件<span class="hljs-number">1</span>:
  <span class="hljs-keyword">case</span> 条件<span class="hljs-number">2</span>:
  ...
  <span class="hljs-keyword">default</span>:
} 
</div></code></pre>
<h2 id="defer">defer</h2>
<ul>
<li><code>defer</code>へ渡した関数の実行を呼び出し元の関数の終わり（returnする）まで遅延させる</li>
<li><code>defer</code>へ渡した関数の引数はすぐに評価されるが、その関数自体は呼び出し元の関数がreturnするまで実行されない</li>
<li><code>defer</code>へ渡した関数が複数ある場合、その呼び出しはスタックされる
→ LIFO（Last In First Out）</li>
</ul>
<h2 id="%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF">ポインタ</h2>
<ul>
<li><code>*p</code>：変数pのポインタ</li>
<li><code>nil</code>：ゼロ値
→ <code>var p *int</code></li>
<li><code>p = &amp;i</code>：ポインタpへのオペレータ</li>
</ul>
<h2 id="%E6%A7%8B%E9%80%A0%E4%BD%93">構造体</h2>
<ul>
<li><code>struct</code>フィールドはドット<code>.</code>を用いてアクセスする</li>
<li>フォーマット</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">type</span> 構造体名 <span class="hljs-keyword">struct</span>{
   メンバ 型
   メンバ 型
   ...
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{
    変数 := 構造体名(値, 値, ...)
    fmt.Println(変数.メンバ, 変数.メンバ...)
}
</div></code></pre>
<h2 id="%E9%85%8D%E5%88%97">配列</h2>
<ul>
<li><font color=Blue><strong>固定長</strong></font></li>
<li>フォーマット
<ul>
<li><code>var 配列名 [個数]型</code></li>
</ul>
</li>
<li>例：）
<ul>
<li><code>var array [10]string</code>：string型の10個の変数の配列<code>array</code></li>
<li><code>b := [10]int{}</code>：int型の10個の変数の配列<code>b</code>
→ この場合、初期値はすべて<code>0</code></li>
</ul>
</li>
</ul>
<h2 id="%E3%82%B9%E3%83%A9%E3%82%A4%E3%82%B9">スライス</h2>
<ul>
<li><font color=Blue><strong>可変長</strong></font>
<ul>
<li>配列への参照のようなもの</li>
</ul>
</li>
<li>フォーマット</li>
</ul>
<pre class="hljs"><code><div>変数<span class="hljs-number">1</span> := [個数]<span class="hljs-keyword">int</span>{値<span class="hljs-number">1</span>, 値<span class="hljs-number">2</span>, 値<span class="hljs-number">3</span>, 値<span class="hljs-number">4</span>, ...}
<span class="hljs-keyword">var</span> 変数<span class="hljs-number">2</span> []<span class="hljs-keyword">int</span> = 変数<span class="hljs-number">1</span>[low:high]
</div></code></pre>
<ul>
<li>概要
<ul>
<li><code>a []int</code>：int型のスライス<code>a</code></li>
<li><code>a[low:high]</code>：インデックス<code>low</code>と<code>high</code>の境界を指定することによってスライスを形成</li>
</ul>
</li>
<li>例：）</li>
</ul>
<pre class="hljs"><code><div>primes := [<span class="hljs-number">6</span>]<span class="hljs-keyword">int</span>{<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">11</span>, <span class="hljs-number">13</span>}
<span class="hljs-keyword">var</span> s []<span class="hljs-keyword">int</span> = primes[<span class="hljs-number">1</span>:<span class="hljs-number">4</span>] <span class="hljs-comment">// [3 5 7]</span>
</div></code></pre>
<ul>
<li>配列との違い
<ul>
<li><code>[3]bool{true, true, false} // 配列</code></li>
<li><code>[]bool{true, true, false} // スライス</code></li>
</ul>
</li>
<li>スライスに直接代入の例
<ul>
<li><code>s := []int{2, 3, 5, 7, 11, 13}</code></li>
</ul>
</li>
<li>【よく使う】構造体スライスの例</li>
</ul>
<pre class="hljs"><code><div>s := []<span class="hljs-keyword">struct</span> {
	i <span class="hljs-keyword">int</span>
	b <span class="hljs-keyword">bool</span>
}{
	{<span class="hljs-number">2</span>, <span class="hljs-literal">true</span>},
	{<span class="hljs-number">3</span>, <span class="hljs-literal">false</span>},
	{<span class="hljs-number">5</span>, <span class="hljs-literal">true</span>},
	{<span class="hljs-number">7</span>, <span class="hljs-literal">true</span>},
	{<span class="hljs-number">11</span>, <span class="hljs-literal">false</span>},
	{<span class="hljs-number">13</span>, <span class="hljs-literal">true</span>},
}
</div></code></pre>
<ul>
<li>「長さ」と「容量」
<ul>
<li>すべて同じ</li>
</ul>
<pre class="hljs"><code><div>s = s[<span class="hljs-number">0</span>:最大]
s = s[:最大]
s = s[<span class="hljs-number">0</span>:]
s = s[:]
</div></code></pre>
</li>
<li><font color=Blue><strong>動的配列の作成</strong></font>
<ul>
<li><code>make</code>関数
<ul>
<li><code>変数 := make([]型, 長さ, 容量)</code>
<ul>
<li>第2引数：長さ, 第3引数：容量</li>
<li>容量を省略すると「長さ = 容量」となる</li>
</ul>
</li>
</ul>
</li>
<li>例：）</li>
</ul>
<pre class="hljs"><code><div>b := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// len(b)=0, cap(b)=5</span>
b = b[:<span class="hljs-built_in">cap</span>(b)]         <span class="hljs-comment">// len(b)=5, cap(b)=5</span>
b = b[<span class="hljs-number">1</span>:]              <span class="hljs-comment">// len(b)=4, cap(b)=4</span>
</div></code></pre>
</li>
<li><font color=Blue><strong>要素の追加</strong></font>
<ul>
<li><code>append</code>関数
<ul>
<li><code>append(変数, 追加要素)</code></li>
</ul>
</li>
<li>例：）</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-keyword">var</span> s []<span class="hljs-keyword">int</span>						
printSlice(s) <span class="hljs-comment">// len=0, cap=0	</span>
s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">0</span>) 	   	
printSlice(s) <span class="hljs-comment">// len=1, cap=1</span>
s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">1</span>) 	   	
printSlice(s) <span class="hljs-comment">// len=2, cap=2</span>
s = <span class="hljs-built_in">append</span>(s, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)  
printSlice(s) <span class="hljs-comment">// len=5, cap=6</span>
</div></code></pre>
<ul>
<li>追加のルール
<ul>
<li><u>元の配列<code>s</code>が変数群を追加する際に容量が小さい場合は、動的により大きいサイズの配列を割り当て直す</u></li>
<li>追加は<code>nil</code>スライスで動作</li>
<li>一度に複数<code>append</code>できる</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="map">Map</h2>
<ul>
<li>『キー』と『値』を関連付ける</li>
<li>フォーマット
<ul>
<li><code>変数 := map[キーの型]値の型{&quot;キー1&quot;: 値1, &quot;キー2&quot;: 値2, ...}</code></li>
<li><u>固定長　配列を生成する場合</u></li>
</ul>
<pre class="hljs"><code><div>変数 := <span class="hljs-keyword">map</span>[キーの型]値の型{
  <span class="hljs-string">"キー1"</span>: 値<span class="hljs-number">1</span>, 
  <span class="hljs-string">"キー2"</span>: 値<span class="hljs-number">2</span>, 
  ...
}
</div></code></pre>
<ul>
<li>例：）<pre class="hljs"><code><div>m := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>{
  	<span class="hljs-string">"go"</span>: <span class="hljs-string">"golang"</span>,
  	<span class="hljs-string">"rb"</span>: <span class="hljs-string">"ruby"</span>,
  	<span class="hljs-string">"js"</span>: <span class="hljs-string">"javascript"</span>,
  }
  fmt.Println(m) <span class="hljs-comment">// map[go:golang js:javascript rb:ruby]</span>
</div></code></pre>
</li>
<li><u>可変長配列を生成する場合</u></li>
</ul>
<pre class="hljs"><code><div>変数 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[キーの型]値の型)
</div></code></pre>
<ul>
<li>例：）<pre class="hljs"><code><div>languages := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)
fmt.Println(languages)            <span class="hljs-comment">// map[]</span>
<span class="hljs-comment">/* 型に則って任意のマップを作成していく */</span>
languages[<span class="hljs-string">"go"</span>] = <span class="hljs-string">"golang"</span>
languages[<span class="hljs-string">"rb"</span>] = <span class="hljs-string">"ruby"</span>
languages[<span class="hljs-string">"js"</span>] = <span class="hljs-string">"javascript"</span>
fmt.Println(languages)            <span class="hljs-comment">// map[go:golang js:javascript rb:ruby]</span>
</div></code></pre>
</li>
</ul>
</li>
<li>mapの変更
<ul>
<li>フォーマット</li>
</ul>
<pre class="hljs"><code><div>変数<span class="hljs-number">1</span> := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[キーの型]値の型)

<span class="hljs-comment">/* 要素の挿入・更新 */</span>
変数<span class="hljs-number">1</span>[キー] = 値
<span class="hljs-comment">/* 要素の削除 */</span>
<span class="hljs-built_in">delete</span>(変数<span class="hljs-number">1</span>, キー)
<span class="hljs-comment">/* 要素の確認 */</span>
変数<span class="hljs-number">2</span>, 変数<span class="hljs-number">3</span> := 変数<span class="hljs-number">1</span>[キー] <span class="hljs-comment">// キー（要素）が存在する場合true / キー（要素）が存在しない場合false</span>
</div></code></pre>
</li>
</ul>
<h2 id="%E3%82%AF%E3%83%AD%E3%83%BC%E3%82%B8%E3%83%A3closure">クロージャ（closure）</h2>
<ul>
<li>参照された変数へアクセスして変えることができる
→ その関数は変数へバインドされている</li>
<li>main内の関数を変数に代入して外部関数に渡せる
→ main内のクロージャに外部からアクセスできる</li>
<li>フォーマット</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> 関数名 <span class="hljs-title">func</span>匿名関数 戻り値の型</span> {
  処理
  <span class="hljs-keyword">return</span> 匿名関数 戻り値の型 {
    処理
    <span class="hljs-keyword">return</span> 戻り値
  }
}
</div></code></pre>
<ul>
<li>例：）①<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
    sum := <span class="hljs-number">0</span> <span class="hljs-comment">// 最初の一度だけ呼び出される</span>
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
    	sum = sum + x
    	<span class="hljs-keyword">return</span> sum
    }
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	pos := adder()
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ {
		fmt.Println(pos(i))
	}
}
</div></code></pre>
</li>
<li>例：）②<pre class="hljs"><code><div><span class="hljs-comment">// laterは「引数に文字列を取り、戻り値に文字列を返す関数」を返す関数</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">later</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> {
	<span class="hljs-comment">// storeはクロージャ内で使われている変数と結び付いた変数</span>
	<span class="hljs-comment">// クロージャと結びついている限り破棄されない</span>
	<span class="hljs-keyword">var</span> store <span class="hljs-keyword">string</span>
	store = <span class="hljs-string">"hoge"</span> <span class="hljs-comment">// 最初の一度だけ呼び出される</span>
	fmt.Println(<span class="hljs-string">"store: "</span> + store) 	  <span class="hljs-comment">// debug</span>

    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(next <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> { <span class="hljs-comment">// クロージャ</span>
    	fmt.Println(<span class="hljs-string">"next: "</span> + next)  <span class="hljs-comment">//debug</span>
    	s := store 	 <span class="hljs-comment">// storeから一つ前に呼び出された文字列を取り出す（mainで変数fを使用している限りstoreの状態は保持される）</span>
  	  store = next <span class="hljs-comment">// 今受け取っている文字列をstoreに格納</span>
  	  <span class="hljs-keyword">return</span> s	 <span class="hljs-comment">// 一つ前の文字列を返す</span>
    } 
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	f := later()
	fmt.Println(<span class="hljs-string">"a: "</span> + f(<span class="hljs-string">"Golang"</span>))
	fmt.Println(<span class="hljs-string">"b: "</span> + f(<span class="hljs-string">"is"</span>))
	fmt.Println(<span class="hljs-string">"c: "</span> + f(<span class="hljs-string">"awesome!"</span>))
}
<span class="hljs-comment">/* 出力
&gt; store:
&gt; next: Golang
&gt; a:
&gt; next: is
&gt; b: Golang
&gt; next: awesome!
&gt; c:is
*/</span>
</div></code></pre>
</li>
</ul>
<hr>
<h2 id="font-colormagenta%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89font"><font color=Magenta>メソッド</font></h2>
<ul>
<li><code>strings.Join()</code>
<ul>
<li><u>各文字列の間に区切り文字を入れて文字列スライスをマージする</u></li>
<li>フォーマット</li>
</ul>
<pre class="hljs"><code><div>変数<span class="hljs-number">1</span> := []型{値<span class="hljs-number">1</span>, 値<span class="hljs-number">2</span>, 値<span class="hljs-number">3</span>, 値<span class="hljs-number">4</span>, ...}
変数<span class="hljs-number">2</span> := strings.Join(変数<span class="hljs-number">1</span>, <span class="hljs-string">"区切り文字"</span>)
</div></code></pre>
<ul>
<li>例：）</li>
</ul>
<pre class="hljs"><code><div>board := [][]<span class="hljs-keyword">string</span>{
	[]<span class="hljs-keyword">string</span>{<span class="hljs-string">"_"</span>, <span class="hljs-string">"_"</span>, <span class="hljs-string">"_"</span>},
	[]<span class="hljs-keyword">string</span>{<span class="hljs-string">"_"</span>, <span class="hljs-string">"_"</span>, <span class="hljs-string">"_"</span>},
	[]<span class="hljs-keyword">string</span>{<span class="hljs-string">"_"</span>, <span class="hljs-string">"_"</span>, <span class="hljs-string">"_"</span>},
}

board[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">"X"</span>
board[<span class="hljs-number">2</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">"O"</span>
board[<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">"X"</span>
board[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-string">"O"</span>
board[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>] = <span class="hljs-string">"X"</span>

merge := strings.Join(board[i], <span class="hljs-string">" "</span>)
</div></code></pre>
</li>
</ul>

</body>
</html>
